from __future__ import annotations

from dataclasses import dataclass
from typing import Any, Dict, List, Protocol

from .config import CommunityAgentConfig
from .message_templates import MessageTemplateContext, SeverityLevel


# --- LLM interface and a simple dummy implementation -------------------------


class LLMClient(Protocol):
    """
    Abstract interface for any small LLM you want to use
    (OpenAI, local model, etc.).
    """

    def generate_text(self, prompt: str, *, system: str | None = None) -> str: ...


class TemplateLLMClient:
    """
    Simple non-API implementation so the agent works even without a real LLM.

    You can replace this with a real client later, e.g.:

        class OpenAILLMClient:
            def __init__(self, client):
                self.client = client

            def generate_text(self, prompt: str, *, system: str | None = None) -> str:
                # call your OpenAI / LLaMA endpoint here
                ...

    """

    def generate_text(self, prompt: str, *, system: str | None = None) -> str:
        header = "Public Health Advisory\n\n"
        if system:
            header = ""
        return (
            header
            + "SUMMARY: This is a placeholder advisory generated by the template LLM client.\n\n"
            + "DETAIL:\n"
            + prompt[:800]
        )


# --- Core data model ---------------------------------------------------------


@dataclass
class CommunityContext:
    """
    Structured inputs for the Community Health Agent.

    You can extend this with more risk factors later.
    """

    location_name: str
    languages: List[str]

    pollution_aqi: int | None = None
    resp_case_trend: str | None = None  # 'stable' | 'rising' | 'falling'
    outbreak_risk: float | None = None  # 0.0–1.0
    outbreak_type: str | None = None
    heat_index: float | None = None
    flood_risk: float | None = None     # 0.0–1.0

    notes: str | None = None


# --- Core agent --------------------------------------------------------------


class CommunityHealthAgent:
    """
    Generates public health advisories based on community-level signals.

    - Uses simple RULES to determine severity.
    - Uses an LLM (or the TemplateLLMClient) to generate multilingual messages.
    """

    def __init__(
        self,
        llm_client: LLMClient | None = None,
        config: CommunityAgentConfig | None = None,
    ) -> None:
        self.config = config or CommunityAgentConfig()
        self.llm_client: LLMClient = llm_client or TemplateLLMClient()

    # ---------------------- Public API ---------------------------------------

    def generate_advisory(self, raw_context: Dict[str, Any]) -> Dict[str, Any]:
        """
        Main entrypoint.

        raw_context: dict, will be converted into CommunityContext.
        Returns: dict with severity, reasons, recommended channels and messages.
        """
        ctx = self._parse_context(raw_context)
        severity, reasons = self._classify_severity(ctx)
        channels = self._recommend_channels(severity)
        messages = self._generate_messages(ctx, severity, reasons)

        return {
            "severity": severity.value,
            "reasons": reasons,
            "recommended_channels": channels,
            "messages": messages,
        }

    # ---------------------- Internal helpers ---------------------------------

    def _parse_context(self, data: Dict[str, Any]) -> CommunityContext:
        languages = data.get("languages") or self.config.default_languages
        location = data.get("location_name") or self.config.default_location_name

        return CommunityContext(
            location_name=location,
            languages=list(languages),
            pollution_aqi=data.get("pollution_aqi"),
            resp_case_trend=data.get("resp_case_trend"),
            outbreak_risk=data.get("outbreak_risk"),
            outbreak_type=data.get("outbreak_type"),
            heat_index=data.get("heat_index"),
            flood_risk=data.get("flood_risk"),
            notes=data.get("notes"),
        )

    def _classify_severity(self, ctx: CommunityContext) -> tuple[SeverityLevel, List[str]]:
        """
        Simple rule-based severity classifier.
        """
        cfg = self.config
        reasons: List[str] = []
        level = SeverityLevel.INFO

        # Pollution
        if ctx.pollution_aqi is not None:
            if ctx.pollution_aqi >= cfg.aqi_emergency:
                level = SeverityLevel.EMERGENCY
                reasons.append(
                    f"AQI is extremely poor ({ctx.pollution_aqi})."
                )
            elif ctx.pollution_aqi >= cfg.aqi_alert:
                level = max(level, SeverityLevel.ALERT, key=self._severity_rank)
                reasons.append(
                    f"AQI is very poor ({ctx.pollution_aqi})."
                )
            elif ctx.pollution_aqi >= cfg.aqi_advisory:
                level = max(level, SeverityLevel.ADVISORY, key=self._severity_rank)
                reasons.append(
                    f"AQI is moderate to unhealthy ({ctx.pollution_aqi})."
                )

        # Outbreak risk
        if ctx.outbreak_risk is not None:
            if ctx.outbreak_risk >= cfg.outbreak_emergency:
                level = SeverityLevel.EMERGENCY
                reasons.append(
                    f"Very high outbreak risk score ({ctx.outbreak_risk:.2f}) "
                    f"for {ctx.outbreak_type or 'infectious disease'}."
                )
            elif ctx.outbreak_risk >= cfg.outbreak_alert:
                level = max(level, SeverityLevel.ALERT, key=self._severity_rank)
                reasons.append(
                    f"High outbreak risk score ({ctx.outbreak_risk:.2f})."
                )
            elif ctx.outbreak_risk >= cfg.outbreak_advisory:
                level = max(level, SeverityLevel.ADVISORY, key=self._severity_rank)
                reasons.append(
                    f"Moderate outbreak risk score ({ctx.outbreak_risk:.2f})."
                )

        # Heat index
        if ctx.heat_index is not None:
            if ctx.heat_index >= cfg.heat_index_emergency:
                level = SeverityLevel.EMERGENCY
                reasons.append(
                    f"Extreme heat index of {ctx.heat_index:.1f}°C."
                )
            elif ctx.heat_index >= cfg.heat_index_alert:
                level = max(level, SeverityLevel.ALERT, key=self._severity_rank)
                reasons.append(
                    f"Very high heat index of {ctx.heat_index:.1f}°C."
                )
            elif ctx.heat_index >= cfg.heat_index_advisory:
                level = max(level, SeverityLevel.ADVISORY, key=self._severity_rank)
                reasons.append(
                    f"High heat index of {ctx.heat_index:.1f}°C."
                )

        # Flood risk
        if ctx.flood_risk is not None:
            if ctx.flood_risk >= cfg.flood_risk_emergency:
                level = SeverityLevel.EMERGENCY
                reasons.append("Extreme flood risk in the area.")
            elif ctx.flood_risk >= cfg.flood_risk_alert:
                level = max(level, SeverityLevel.ALERT, key=self._severity_rank)
                reasons.append("High flood risk in the area.")
            elif ctx.flood_risk >= cfg.flood_risk_advisory:
                level = max(level, SeverityLevel.ADVISORY, key=self._severity_rank)
                reasons.append("Moderate flood risk in the area.")

        # Respiratory case trend
        if ctx.resp_case_trend == "rising":
            level = max(level, SeverityLevel.ADVISORY, key=self._severity_rank)
            reasons.append("Respiratory cases are rising in clinics and hospitals.")

        if not reasons:
            reasons.append("No major risks detected, sending general health information.")

        return level, reasons

    @staticmethod
    def _severity_rank(level: SeverityLevel) -> int:
        order = {
            SeverityLevel.INFO: 0,
            SeverityLevel.ADVISORY: 1,
            SeverityLevel.ALERT: 2,
            SeverityLevel.EMERGENCY: 3,
        }
        return order[level]

    def _recommend_channels(self, severity: SeverityLevel) -> List[str]:
        if severity == SeverityLevel.EMERGENCY:
            return ["SMS", "WhatsApp", "Loudspeaker", "Local TV/Radio"]
        if severity == SeverityLevel.ALERT:
            return ["SMS", "WhatsApp", "Social Media", "Posters"]
        if severity == SeverityLevel.ADVISORY:
            return ["WhatsApp", "Social Media", "Posters"]
        return ["Social Media"]

    def _generate_messages(
        self,
        ctx: CommunityContext,
        severity: SeverityLevel,
        reasons: List[str],
    ) -> Dict[str, str]:
        """
        Call the LLM (or dummy template LLM) for each language.
        """
        template_ctx = MessageTemplateContext(
            location_name=ctx.location_name,
            severity=severity,
            reasons=reasons,
            languages=ctx.languages,
            notes=ctx.notes,
        )

        system = template_ctx.build_system_instruction()
        result: Dict[str, str] = {}

        for lang in ctx.languages:
            prompt = template_ctx.build_user_prompt(lang)
            text = self.llm_client.generate_text(prompt=prompt, system=system)
            result[lang] = text

        return result


# --- Simple CLI demo ---------------------------------------------------------


def demo() -> None:
    agent = CommunityHealthAgent()

    example = {
        "location_name": "Nagpur",
        "languages": ["en", "hi"],
        "pollution_aqi": 210,
        "resp_case_trend": "rising",
        "outbreak_risk": 0.65,
        "outbreak_type": "dengue",
        "heat_index": 41.0,
        "flood_risk": 0.2,
        "notes": "School exams are ongoing, avoid panic messaging.",
    }

    result = agent.generate_advisory(example)
    print("Severity:", result["severity"])
    print("Reasons:")
    for r in result["reasons"]:
        print(" -", r)

    print("\nRecommended channels:", ", ".join(result["recommended_channels"]))
    print("\nMessages:")
    for lang, msg in result["messages"].items():
        print(f"\n--- [{lang}] ---\n{msg}\n")


if __name__ == "__main__":
    demo()
